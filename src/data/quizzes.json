[
  {
    "id": 1,
    "title": "Compose의 Scoped Lifecycles",
    "description": "Android Compose에서 컴포저블별 생명주기 제어에 대해 학습합니다.",
    "difficulty": "intermediate",
    "articleUrl": "https://proandroiddev.com/scoped-lifecycles-in-compose-71670142c19e",
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "기존 LocalLifecycleOwner의 주요 특징 또는 한계점은 무엇입니까?",
        "options": [
          "각 컴포저블에 대해 새로운 LifecycleOwner를 생성합니다.",
          "주로 MapView 및 비디오 플레이어에 사용됩니다.",
          "주어진 Activity 내의 모든 컴포저블이 동일한 LifecycleOwner를 공유합니다.",
          "실수로 인한 더블 탭을 자동으로 방지할 수 있습니다.",
          "현재 전환 및 백 스택 상태에 따라 상태가 결정됩니다."
        ],
        "correct": 2,
        "explanation": "LocalLifecycleOwner는 window.decorView에 의해 설정된 LifecycleOwner를 가져오기 때문에, 주어진 Activity 내의 모든 컴포저블이 동일한 LifecycleOwner를 공유합니다."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "단일 컴포저블 스택에서 전환(팝/푸시) 중 화면에 대한 바람직한 생명주기 상태는 무엇입니까?",
        "options": [
          "백 스택에 있고 전환 중일 때 RESUMED 상태입니다.",
          "화면이 안정되었을 때만 STARTED 상태입니다.",
          "화면이 아직 애니메이션으로 들어오고 있을 때 CREATED 상태입니다.",
          "백 스택에 있고 '안정되었을' 때(전환이 실행되지 않음) RESUMED 상태, 백 스택에 있지만 전환 중일 때 STARTED 상태, 백 스택에 없지만 애니메이션으로 나갈 때 CREATED 상태입니다.",
          "들어오는 컴포저블과 나가는 컴포저블 모두 잠시 RESUMED 상태에 진입합니다."
        ],
        "correct": 3,
        "explanation": "원하는 생명주기 상태는 다음과 같습니다: 화면이 백 스택에 있고 '안정되었을' 때(전환이 실행되지 않음)에만 RESUMED, 백 스택에 있지만 전환 중일 때 STARTED, 더 이상 백 스택에 없지만(예: 팝된 상태) 여전히 애니메이션으로 나갈 때 CREATED입니다."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "LifecycleOwner 컴포저블은 어떻게 컴포저블별 생명주기 제어를 달성합니까?",
        "options": [
          "View의 findViewTreeLifecycleOwner()에서 viewTreeOwners를 검사함으로써.",
          "Activity의 모든 컴포저블이 동일한 LifecycleOwner를 공유하도록 보장함으로써.",
          "자체적으로 새로운 LifecycleOwner를 생성하고, DisposableEffect를 통해 자식의 생명주기를 부모의 생명주기와 연결하며, maxLifecycle에 의해 제한함으로써.",
          "항상 maxLifecycle을 RESUMED로 설정함으로써.",
          "window.decorView의 LifecycleOwner를 오버라이드함으로써."
        ],
        "correct": 2,
        "explanation": "새로운 LifecycleOwner 컴포저블은 LifecycleOwner 내부에서 새로운 LifecycleOwner를 생성하고, DisposableEffect는 자식의 생명주기를 부모의 생명주기와 연결합니다. 또한 ChildLifecycleOwner는 maxLifecycle에 의해 제한되어 부모의 생명주기에 반응하여 자체 상태를 조정합니다."
      }
    ]
  },
  {
    "id": 2,
    "title": "Kotlin 코루틴 공식 가이드 완독하기 Part 1",
    "description": "Kotlin 코루틴의 기본 개념과 GlobalScope, runBlocking, suspend 함수에 대해 학습합니다.",
    "difficulty": "intermediate",
    "articleUrl": "https://myungpyo.medium.com/reading-coroutine-official-guide-thoroughly-part-1-98f6e792bd5b",
    "questions": [
      {
        "id": 1,
        "type": "multiple_choice",
        "question": "메인 함수에서 GlobalScope.launch {} 코드 블록을 사용하고, 2초간 정지(Sleep)와 같은 명시적인 지연 코드를 사용하지 않을 경우 프로그램의 동작으로 가장 적절한 것은 무엇입니까?",
        "options": [
          "코루틴이 완료될 때까지 메인 함수가 자동으로 대기합니다.",
          "GlobalScope.launch {} 블록이 메인 스레드를 블록하여 코루틴 실행을 기다립니다.",
          "메인 함수가 코루틴의 종료를 기다리지 않고 즉시 종료되어, 코루틴이 작업을 마치기 전에 프로그램이 끝날 수 있습니다.",
          "GlobalScope.launch {} 블록은 스스로 자식 코루틴들의 완료를 기다립니다.",
          "메모리 부족(Out-Of-Memory) 오류가 발생합니다."
        ],
        "correct": 2,
        "explanation": "GlobalScope.launch {} 코드 블록은 코루틴을 생성하는 빌더이며, 이렇게 생성된 코루틴은 호출(실행) 스레드를 블록하지 않습니다. 따라서 메인 함수에 명시적인 지연 코드가 없으면, 메인 함수가 코루틴의 완료를 기다리지 않고 종료되어 메인 스레드도 함께 종료되고, 결국 프로그램이 끝나 버립니다."
      },
      {
        "id": 2,
        "type": "multiple_choice",
        "question": "자식 코루틴들의 완료를 기다리는 코루틴 빌더인 runBlocking{}과 coroutineScope{}의 주요 차이점은 무엇입니까?",
        "options": [
          "runBlocking{}은 현재 스레드를 블록하지 않는 반면, coroutineScope{}는 현재 스레드를 블록합니다.",
          "runBlocking{}은 코루틴 안에서 사용이 권장되지 않는 반면, coroutineScope{}는 코루틴 내부에서만 사용될 수 있습니다.",
          "runBlocking{}은 자식들의 종료를 기다리는 동안 현재 스레드를 블록하는 반면, coroutineScope{}는 자식들의 종료를 기다리는 동안 현재 스레드를 블록하지 않습니다.",
          "coroutineScope{}는 명시적으로 job.join()을 호출해야 하지만, runBlocking{}은 그렇지 않습니다.",
          "runBlocking{}은 항상 다른 코루틴 빌더보다 먼저 실행됩니다."
        ],
        "correct": 2,
        "explanation": "runBlocking{}은 주어진 블록이 완료될 때까지 현재 스레드를 멈추는(블록하는) 새로운 코루틴을 생성하여 실행합니다. 반면, coroutineScope{}는 모든 자식 코루틴들이 끝날 때까지 종료되지 않는 스코프를 정의하지만, 자식들의 종료를 기다리는 동안 현재 스레드를 블록하지 않습니다."
      },
      {
        "id": 3,
        "type": "multiple_choice",
        "question": "suspend 키워드를 사용하여 정의된 중단 함수(suspending function)의 특징으로 옳은 것은 무엇입니까?",
        "options": [
          "반드시 GlobalScope.launch {} 블록 내에서만 호출될 수 있습니다.",
          "일반 함수와 마찬가지로 어떠한 제약 없이 다른 중단 함수를 호출할 수 있습니다.",
          "delay()와 같은 다른 중단 함수들을 호출할 수 없으며, 일반적인 함수처럼 동작합니다.",
          "이 함수 역시 중단 함수이기 때문에 특정 코루틴 컨텍스트 안에서 수행되며, 따라서 delay()와 같은 다른 중단 함수들을 호출할 수 있습니다.",
          "이 함수는 항상 새로운 스레드를 생성하여 코드를 실행합니다."
        ],
        "correct": 3,
        "explanation": "suspend 키워드를 함수명 앞에 붙여 만든 함수는 중단 함수이며, 이러한 함수는 delay()와 같은 다른 중단 함수들을 호출할 수 있습니다. 그 이유는 suspend 함수가 특정 코루틴 컨텍스트 안에서 수행되고, 코루틴 컨텍스트 안에서는 모든 중단 함수를 호출할 수 있기 때문입니다."
      }
    ]
  }
]